/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

'use client';

import {
    type Address,
    type Rpc,
    type RpcSubscriptions,
    type SolanaRpcApi,
    type SolanaRpcSubscriptionsApi,
} from '@solana/kit';
import { useEffect, useMemo, useState } from 'react';
import { findCounterPda, getCounterDecoder, type Counter, type CounterSeeds } from '../';

type useCounterConfig = {
    rpc: Rpc<SolanaRpcApi>;
    rpcSubscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>;
};

export function useCounter(address: Address, config: useCounterConfig) {
    const [data, setData] = useState<Counter | null>(null);
    const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
    const [error, setError] = useState<Error | null>(null);
    const decoder = useMemo(() => getCounterDecoder(), []);

    useEffect(() => {
        setStatus('loading');
        const abortController = new AbortController();
        const subscription = config.rpcSubscriptions
            .accountNotifications(address, { encoding: 'base64' })
            .subscribe({ abortSignal: abortController.signal });

        (async () => {
            try {
                for await (const notification of await subscription) {
                    const rawData = notification.value.data as unknown as Uint8Array;
                    setData(decoder.decode(rawData));
                    setStatus('success');
                }
            } catch (e) {
                if (!abortController.signal.aborted) {
                    setError(e instanceof Error ? e : new Error(String(e)));
                    setStatus('error');
                }
            }
        })();

        return () => abortController.abort();
    }, [address, config.rpcSubscriptions, decoder]);

    return { data, error, status };
}

type useCounterFromSeedsConfig = {
    rpc: Rpc<SolanaRpcApi>;
    rpcSubscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>;
    programAddress?: Address;
};

export function useCounterFromSeeds(seeds: CounterSeeds, config: useCounterFromSeedsConfig) {
    const [address, setAddress] = useState<Address | null>(null);
    const [data, setData] = useState<Counter | null>(null);
    const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
    const [error, setError] = useState<Error | null>(null);
    const decoder = useMemo(() => getCounterDecoder(), []);

    // Derive PDA address.
    useEffect(() => {
        let cancelled = false;
        setStatus('loading');
        (async () => {
            try {
                const [pda] = await findCounterPda(seeds, { programAddress: config.programAddress });
                if (!cancelled) setAddress(pda);
            } catch (e) {
                if (!cancelled) {
                    setError(e instanceof Error ? e : new Error(String(e)));
                    setStatus('error');
                }
            }
        })();
        return () => {
            cancelled = true;
        };
    }, [config.programAddress, seeds]);

    // Subscribe to account once address is derived.
    useEffect(() => {
        if (!address) return;
        setStatus('loading');
        const abortController = new AbortController();
        const subscription = config.rpcSubscriptions
            .accountNotifications(address, { encoding: 'base64' })
            .subscribe({ abortSignal: abortController.signal });

        (async () => {
            try {
                for await (const notification of await subscription) {
                    const rawData = notification.value.data as unknown as Uint8Array;
                    setData(decoder.decode(rawData));
                    setStatus('success');
                }
            } catch (e) {
                if (!abortController.signal.aborted) {
                    setError(e instanceof Error ? e : new Error(String(e)));
                    setStatus('error');
                }
            }
        })();

        return () => abortController.abort();
    }, [address, config.rpcSubscriptions, decoder]);

    return { address, data, error, status };
}

type useCountersConfig = {
    rpc: Rpc<SolanaRpcApi>;
};

export function useCounters(addresses: Address[], config: useCountersConfig) {
    const [data, setData] = useState<(Counter | null)[]>([]);
    const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
    const [error, setError] = useState<Error | null>(null);
    const decoder = useMemo(() => getCounterDecoder(), []);

    const addressesKey = addresses.join(',');

    useEffect(() => {
        if (addresses.length === 0) {
            setData([]);
            setStatus('success');
            return;
        }

        let cancelled = false;
        setStatus('loading');

        (async () => {
            try {
                const encodedAccounts = await config.rpc.getMultipleAccounts(addresses, { encoding: 'base64' }).send();
                if (cancelled) return;

                const decoded = encodedAccounts.value.map(account => {
                    if (!account || !account.data) return null;
                    return decoder.decode(account.data[0] as unknown as Uint8Array);
                });
                setData(decoded);
                setStatus('success');
            } catch (e) {
                if (!cancelled) {
                    setError(e instanceof Error ? e : new Error(String(e)));
                    setStatus('error');
                }
            }
        })();

        return () => {
            cancelled = true;
        };
    }, [addressesKey, config.rpc, decoder]);

    return { data, error, status };
}
